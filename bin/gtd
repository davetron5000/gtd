#!/usr/bin/env ruby
require "gli"
require "gtd"
require "pathname"
require "rainbow"

include GLI::App

program_desc "Manage a basic todo list and project list, GTD-style"

version Gtd::VERSION

subcommand_option_handling :normal
arguments :strict

desc "Root location for files"
flag :root, default_value: Pathname(ENV["HOME"]) / "Dropbox" / "GTD"

desc "Use colored output"
switch :color, default_value: true

desc "Create a new fresh todo list"
command :init do |c|
  c.action do |global,options,args|
    if $todo_txt.tasks.empty?
      $todo_txt.tasks << Gtd::Task.new(description: "Capture some tasks or projects")
      $todo_txt.save!
    else
      exit_now!("#{$todo_txt.file} already exists—not overwriting")
    end
  end
end

desc "List tasks"
arg :search_string, :optional
command :ls do |c|
  c.desc "Show only completed tasks"
  c.switch [:completed,:done]

  c.action do |global,options,args|
    tasks = if options[:done]
              $todo_txt.tasks.select(&:completed?)
            else
              $todo_txt.tasks.reject(&:completed?)
            end
    formatter = Gtd::TaskFormatter.new
    tasks.each do |task|
      puts formatter.format(task)
    end
  end
end

desc "Add a new task"
long_desc %{
  Adds a new task to the main task list.  You can either provide the text of the command, along with the necessary @context and +project demarcations, or you can promote a task from a project's task list using -p

  -p will take the next action of that project and put it into the main task list.
}
arg_name "[task description]"
command [:new] do |c|

  c.desc "Add the next action from «project_id»"
  c.arg_name "project_id"
  c.flag ["from-project","p"]

  c.action do |global,options,args|
    if options["from-project"]
      project = $projects.find(options["from-project"].to_i)
      next_action = project.todo_txt.tasks.first
      $todo_txt.tasks << next_action
      project.todo_txt.remove(next_action)
      project.todo_txt.save!
    else
      $todo_txt.tasks << Gtd::Task.new(description: args.join(" "))
    end
    $todo_txt.save!
  end
end

desc "Edit the task list directly in your configured $EDITOR"
command [:edit,:vi] do |c|
  c.action do |global,options,args|
    editor = ENV["EDITOR"]
    system("#{editor} '#{$todo_txt.file}'")
  end
end

desc "Mark a task complete"
arg :task_id
command [:done,:complete] do |c|
  c.action do |global,options,args|
    $todo_txt.complete_task(args[0].to_i)
    $todo_txt.save!
  end
end

desc "Projects"
command [:p, :projects] do |c|
  c.desc "List tasks"
  c.arg :project_id
  c.command :tasks do |tasks|
    tasks.action do |global,options,args|
      project = $projects.find(args[0].to_i)
      formatter = Gtd::TaskFormatter.new
      project.todo_txt.tasks.each do |task|
        puts formatter.format(task)
      end
    end
  end

  c.desc "List projects"
  c.command :ls do |ls|
    ls.action do |global,options,args|
      formatter = Gtd::ProjectFormatter.new
      $projects.each do |project|
        puts formatter.format(project)
      end
    end
  end
  c.default_command :ls
end

pre do |global,command,options,args|
  Rainbow.enabled = global[:color]
  $todo_txt = Gtd::TodoTxt.new(Pathname(global[:root]) / "todo.txt")
  $projects = Gtd::Projects.new(Pathname(global[:root]) / "projects")
  true
end

post do |global,command,options,args|
end

on_error do |exception|
  true
end

exit run(ARGV)
